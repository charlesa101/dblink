import com.github.ngmarchant.dblink.StrFieldIndex
import com.github.liblevenshtein.transducer.Algorithm
import com.github.liblevenshtein.transducer.factory.TransducerBuilder
import com.github.liblevenshtein.transducer.Candidate
import com.eatthepath.jvptree._

import org.apache.commons.lang3.StringUtils.getLevenshteinDistance
import scala.collection.JavaConverters._
import scala.math.{exp, max}

val stringToId = Map(("John", 0), ("Johnny", 1), ("Neil", 2), ("Phil", 3), ("Jenny", 4), ("Jon", 5), ("", 6), ("a", 7))

val transducer = new TransducerBuilder()
  .algorithm(Algorithm.TRANSPOSITION)
  .defaultMaxDistance(3)
  .dictionary(stringToId.keys.asJavaCollection)
  .build[Candidate]()

val value1 = ""
val simThreshold = 0.4
val strDistTemp = 0.2
val mLength = stringToId.keys.foldLeft(0)((max, string) => if (string.length > max) string.length else max)
val maxDist = math.ceil((1 - simThreshold)*mLength).toInt
transducer.transduce(value1, maxDist).asScala
val candidates = transducer.transduce(value1, maxDist).iterator().asScala
candidates.foreach{ candidate =>
  val value2 = candidate.term()
  val valueId2 = stringToId(value2)
  val maxLength = max(value1.length, value2.length)
  val normSim = if (maxLength == 0) 1.0 else 1.0 - candidate.distance().toDouble/maxLength
  val transSim = (normSim - simThreshold)/(1.0 - simThreshold)
  if (transSim >= 0.0) println(s"$value2 -> ${exp(transSim / strDistTemp)}")
}

class NormLev extends DistanceFunction[String] {
  override def getDistance(firstPoint: String, secondPoint: String): Double = getLevenshteinDistance(firstPoint, secondPoint).toDouble
}

val vpTree = new VPTree[String, String](new NormLev, stringToId.keys.asJavaCollection)
vpTree.getAllWithinDistance("Phill", 3.0)